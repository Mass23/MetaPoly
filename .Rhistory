return(data.frame(gene_id=gene, cor=cor, p=p, mean_coef=mean_coef, low_ci=low_ci, high_ci=high_ci))}
#else{return(data.frame(gene_id=gene, cor=NA, p=NA, mean_coef=NA, low_ci=NA, high_ci=NA))}}
#' PolyCorr
#'
#' This functions computes the gene-wise correlation between the number of SNPs, and a target
#' variable than can be either continuous, either discrete (handles two treatments). It creates
#' a zero-inflated poisson model of the SNP count, taking the sample, log(sequencing depth),
#' and the gene length as fixed effects. The idea is to identify genes showing signs of selective
#' sweeps associated with the target variable. There are three inputs:
#'   - data: the polymorphism data created by MetaPoly's "GetGenesData" function
#'   - min_samp: the minimal number of sample having the required depth to run the correlation test.
#'   - samp_vec: a vector that assigns each sample (vector values) to each population (vector
#'     names). The method handles two populations encoded as 0 and 1's.
#'
#' @export
PolyCorr <- function(data, min_samp, samp_vec, p_corr='holm'){
print('Launching - MetaPoly PolyCorr: a polymorphism-variable correlation tool for metagenomic data')
t0 = Sys.time()
print(' - Fitting a zero-inflated poisson model on the data...')
data = as.data.table(data[,colnames(data) %in% c('SNP_N', 'DEPTH', 'gene_length', 'sample', 'gene_id')])
model_df = data[data$DEPTH>0,]
model = pscl::zeroinfl(SNP_N ~ log(DEPTH) + gene_length + as.factor(sample) | log(DEPTH), data = model_df)
print(summary(model))
model_df$res_m = model$residuals
model_df$variable = vapply(model_df$sample, function(x) as.numeric(names(samp_vec)[samp_vec == x]), numeric(1))
print(Sys.time() - t0)
print(' - Computing sample coefficients...')
coefs = coefficients(model)
coefs = coefs[startsWith(names(coefs),'count_as.factor(sample)')]
coefs_df = as.data.frame(coefs)
rownames(coefs_df) = vapply(rownames(coefs_df), function(x) strsplit(x, ')')[[1]][2], FUN.VALUE = character(1))
coefs_df$type = vapply(rownames(coefs_df), function(x) as.numeric(names(samp_vec)[samp_vec == x]), numeric(1))
print(Sys.time() - t0)
print(' - Computing correlations of polymorphism with the variable of interest per gene...')
corr_df = do.call(rbind, lapply(unique(model_df$gene_id), function(gene) fit_cor_gene(model_df[model_df$gene_id == gene,], gene, min_samp, samp_vec)))
corr_df$padj = p.adjust(corr_df$p, method = p_corr)
sign_genes = corr_df[corr_df$padj < 0.05,]
pos_genes = as.vector(na.omit(sign_genes$gene_id[sign_genes$cor > 0]))
neg_genes = as.vector(na.omit(sign_genes$gene_id[sign_genes$cor < 0]))
print(Sys.time() - t0)
print(' - Analysis done!')
return(list(pi_corr_res = corr_df, pos_genes = pos_genes, neg_genes = neg_genes, coefs = coefs_df))}
mt_polycorr = PolyCorr(mt_poly, 9, samples_vec, 'holm')
################# POLYCORR #################
fit_cor_gene <- function(gene_data, gene, min_samp, samp_vec){
gene_data = na.omit(gene_data[gene_data$DEPTH > 0,])
if (length(unique(gene_data$sample)) > min_samp){
cor_test = cor.test(gene_data$res_m, gene_data$variable)
p = as.numeric(cor_test$p.value)
cor = as.numeric(cor_test$estimate)
mean_coef = mean(gene_data$res_m, na.rm=T)
low_ci = cor_test$conf.int[1]
high_ci = cor_test$conf.int[2]
return(data.frame(gene_id=gene, cor=cor, p=p, mean_coef=mean_coef, low_ci=low_ci, high_ci=high_ci))}
else{return(data.frame(gene_id=gene, cor=NA, p=NA, mean_coef=NA, low_ci=NA, high_ci=NA))}}
#' variable than can be either continuous, either discrete (handles two treatments). It creates
#' a zero-inflated poisson model of the SNP count, taking the sample, log(sequencing depth),
#' and the gene length as fixed effects. The idea is to identify genes showing signs of selective
#' sweeps associated with the target variable. There are three inputs:
#'   - data: the polymorphism data created by MetaPoly's "GetGenesData" function
#'   - min_samp: the minimal number of sample having the required depth to run the correlation test.
#'   - samp_vec: a vector that assigns each sample (vector values) to each population (vector
#'     names). The method handles two populations encoded as 0 and 1's.
#'
#' @export
PolyCorr <- function(data, min_samp, samp_vec, p_corr='holm'){
print('Launching - MetaPoly PolyCorr: a polymorphism-variable correlation tool for metagenomic data')
t0 = Sys.time()
print(' - Fitting a zero-inflated poisson model on the data...')
data = as.data.table(data[,colnames(data) %in% c('SNP_N', 'DEPTH', 'gene_length', 'sample', 'gene_id')])
model_df = data[data$DEPTH>0,]
model = pscl::zeroinfl(SNP_N ~ log(DEPTH) + gene_length + as.factor(sample) | log(DEPTH), data = model_df)
print(summary(model))
model_df$res_m = model$residuals
model_df$variable = vapply(model_df$sample, function(x) as.numeric(names(samp_vec)[samp_vec == x]), numeric(1))
print(Sys.time() - t0)
print(' - Computing sample coefficients...')
coefs = coefficients(model)
coefs = coefs[startsWith(names(coefs),'count_as.factor(sample)')]
coefs_df = as.data.frame(coefs)
rownames(coefs_df) = vapply(rownames(coefs_df), function(x) strsplit(x, ')')[[1]][2], FUN.VALUE = character(1))
coefs_df$type = vapply(rownames(coefs_df), function(x) as.numeric(names(samp_vec)[samp_vec == x]), numeric(1))
print(Sys.time() - t0)
print(' - Computing correlations of polymorphism with the variable of interest per gene...')
corr_df = do.call(rbind, lapply(unique(model_df$gene_id), function(gene) fit_cor_gene(model_df[model_df$gene_id == gene,], gene, min_samp, samp_vec)))
corr_df$padj = p.adjust(corr_df$p, method = p_corr)
sign_genes = corr_df[corr_df$padj < 0.05,]
pos_genes = as.vector(na.omit(sign_genes$gene_id[sign_genes$cor > 0]))
neg_genes = as.vector(na.omit(sign_genes$gene_id[sign_genes$cor < 0]))
print(Sys.time() - t0)
print(' - Analysis done!')
return(list(pi_corr_res = corr_df, pos_genes = pos_genes, neg_genes = neg_genes, coefs = coefs_df))}
mt_polycorr = PolyCorr(mt_poly, 9, samples_vec, 'holm')
PlotPolyCorr(mt_polycorr$pi_corr_res, mt_polycorr$coefs, 'fig_polycorr', boolean_var = F)
mt_polycorr$pi_corr_res[mt_polycorr$pi_corr_res$padj < 0.05,]
mt_polycorr$pi_corr_res[mt_polycorr$pi_corr_res$gene_id == 'HAEMFFGE_00898',]
mt_polycorr$pi_corr_res[mt_polycorr$pi_corr_res$gene_id == 'HAEMFFGE_00899',]
mt_polycorr$pi_corr_res[mt_polycorr$pi_corr_res$gene_id == 'HAEMFFGE_00989',]
metadata$time_diff
names(samples_vec) = metadata$time_diff
mt_polycorr = PolyCorr(mt_poly, 9, samples_vec, 'holm')
PlotPolyCorr(mt_polycorr$pi_corr_res, mt_polycorr$coefs, 'fig_polycorr', boolean_var = F)
PlotPolyCorr(mt_polycorr$pi_corr_res, mt_polycorr$coefs, 'fig_polycorr', boolean_var = F)
PolyCorr <- function(data, min_samp, samp_vec, p_corr='holm'){
print('Launching - MetaPoly PolyCorr: a polymorphism-variable correlation tool for metagenomic data')
t0 = Sys.time()
print(' - Fitting a zero-inflated poisson model on the data...')
data = as.data.table(data[,colnames(data) %in% c('SNP_N', 'DEPTH', 'gene_length', 'sample', 'gene_id')])
#data = data[data$DEPTH>0,]
model = pscl::zeroinfl(SNP_N ~ log(DEPTH) + gene_length + as.factor(sample) | log(DEPTH), data = data)
print(summary(model))
model_df$res_m = model$residuals
model_df$variable = vapply(model_df$sample, function(x) as.numeric(names(samp_vec)[samp_vec == x]), numeric(1))
print(Sys.time() - t0)
print(' - Computing sample coefficients...')
coefs = coefficients(model)
coefs = coefs[startsWith(names(coefs),'count_as.factor(sample)')]
coefs_df = as.data.frame(coefs)
rownames(coefs_df) = vapply(rownames(coefs_df), function(x) strsplit(x, ')')[[1]][2], FUN.VALUE = character(1))
coefs_df$type = vapply(rownames(coefs_df), function(x) as.numeric(names(samp_vec)[samp_vec == x]), numeric(1))
print(Sys.time() - t0)
print(' - Computing correlations of polymorphism with the variable of interest per gene...')
corr_df = do.call(rbind, lapply(unique(model_df$gene_id), function(gene) fit_cor_gene(model_df[model_df$gene_id == gene,], gene, min_samp, samp_vec)))
corr_df$padj = p.adjust(corr_df$p, method = p_corr)
sign_genes = corr_df[corr_df$padj < 0.05,]
pos_genes = as.vector(na.omit(sign_genes$gene_id[sign_genes$cor > 0]))
neg_genes = as.vector(na.omit(sign_genes$gene_id[sign_genes$cor < 0]))
print(Sys.time() - t0)
print(' - Analysis done!')
return(list(pi_corr_res = corr_df, pos_genes = pos_genes, neg_genes = neg_genes, coefs = coefs_df))}
mt_polycorr = PolyCorr(mt_poly, 9, samples_vec, 'holm')
mt_poly
#' variable than can be either continuous, either discrete (handles two treatments). It creates
#' a zero-inflated poisson model of the SNP count, taking the sample, log(sequencing depth),
#' and the gene length as fixed effects. The idea is to identify genes showing signs of selective
#' sweeps associated with the target variable. There are three inputs:
#'   - data: the polymorphism data created by MetaPoly's "GetGenesData" function
#'   - min_samp: the minimal number of sample having the required depth to run the correlation test.
#'   - samp_vec: a vector that assigns each sample (vector values) to each population (vector
#'     names). The method handles two populations encoded as 0 and 1's.
#'
#' @export
PolyCorr <- function(data, min_samp, samp_vec, p_corr='holm'){
print('Launching - MetaPoly PolyCorr: a polymorphism-variable correlation tool for metagenomic data')
t0 = Sys.time()
print(' - Fitting a zero-inflated poisson model on the data...')
data = as.data.table(data[,colnames(data) %in% c('SNP_N', 'DEPTH', 'gene_length', 'sample', 'gene_id')])
data = na.omit(data)
model = pscl::zeroinfl(SNP_N ~ log(DEPTH) + gene_length + as.factor(sample) | log(DEPTH), data = data)
print(summary(model))
model_df$res_m = model$residuals
model_df$variable = vapply(model_df$sample, function(x) as.numeric(names(samp_vec)[samp_vec == x]), numeric(1))
print(Sys.time() - t0)
print(' - Computing sample coefficients...')
coefs = coefficients(model)
coefs = coefs[startsWith(names(coefs),'count_as.factor(sample)')]
coefs_df = as.data.frame(coefs)
rownames(coefs_df) = vapply(rownames(coefs_df), function(x) strsplit(x, ')')[[1]][2], FUN.VALUE = character(1))
coefs_df$type = vapply(rownames(coefs_df), function(x) as.numeric(names(samp_vec)[samp_vec == x]), numeric(1))
print(Sys.time() - t0)
print(' - Computing correlations of polymorphism with the variable of interest per gene...')
corr_df = do.call(rbind, lapply(unique(model_df$gene_id), function(gene) fit_cor_gene(model_df[model_df$gene_id == gene,], gene, min_samp, samp_vec)))
corr_df$padj = p.adjust(corr_df$p, method = p_corr)
sign_genes = corr_df[corr_df$padj < 0.05,]
pos_genes = as.vector(na.omit(sign_genes$gene_id[sign_genes$cor > 0]))
neg_genes = as.vector(na.omit(sign_genes$gene_id[sign_genes$cor < 0]))
print(Sys.time() - t0)
print(' - Analysis done!')
return(list(pi_corr_res = corr_df, pos_genes = pos_genes, neg_genes = neg_genes, coefs = coefs_df))}
mt_polycorr = PolyCorr(mt_poly, 9, samples_vec, 'holm')
samples_vec
######################################################################################################
# POLYCORR
# 1. data generation
metadata$time_diff = log(abs(as.integer(metadata$Date - as.Date(metadata$Date[metadata$Sample == 'D15']))+1))
samples_vec = metadata$Sample
names(samples_vec) = metadata$time_diff
mt_polycorr = PolyCorr(mt_poly, 9, samples_vec, 'holm')
samples_vec
na.omit(mt_poly)
#' variable than can be either continuous, either discrete (handles two treatments). It creates
#' a zero-inflated poisson model of the SNP count, taking the sample, log(sequencing depth),
#' and the gene length as fixed effects. The idea is to identify genes showing signs of selective
#' sweeps associated with the target variable. There are three inputs:
#'   - data: the polymorphism data created by MetaPoly's "GetGenesData" function
#'   - min_samp: the minimal number of sample having the required depth to run the correlation test.
#'   - samp_vec: a vector that assigns each sample (vector values) to each population (vector
#'     names). The method handles two populations encoded as 0 and 1's.
#'
#' @export
PolyCorr <- function(data, min_samp, samp_vec, p_corr='holm'){
print('Launching - MetaPoly PolyCorr: a polymorphism-variable correlation tool for metagenomic data')
t0 = Sys.time()
print(' - Fitting a zero-inflated poisson model on the data...')
data = as.data.table(data[,colnames(data) %in% c('SNP_N', 'DEPTH', 'gene_length', 'sample', 'gene_id')])
model_df = na.omit(data)
model = pscl::zeroinfl(SNP_N ~ log(DEPTH) + gene_length + as.factor(sample) | log(DEPTH), data = model_df)
print(summary(model))
model_df$res_m = model$residuals
model_df$variable = vapply(model_df$sample, function(x) as.numeric(names(samp_vec)[samp_vec == x]), numeric(1))
print(Sys.time() - t0)
print(' - Computing sample coefficients...')
coefs = coefficients(model)
coefs = coefs[startsWith(names(coefs),'count_as.factor(sample)')]
coefs_df = as.data.frame(coefs)
rownames(coefs_df) = vapply(rownames(coefs_df), function(x) strsplit(x, ')')[[1]][2], FUN.VALUE = character(1))
coefs_df$type = vapply(rownames(coefs_df), function(x) as.numeric(names(samp_vec)[samp_vec == x]), numeric(1))
print(Sys.time() - t0)
print(' - Computing correlations of polymorphism with the variable of interest per gene...')
corr_df = do.call(rbind, lapply(unique(model_df$gene_id), function(gene) fit_cor_gene(model_df[model_df$gene_id == gene,], gene, min_samp, samp_vec)))
corr_df$padj = p.adjust(corr_df$p, method = p_corr)
sign_genes = corr_df[corr_df$padj < 0.05,]
pos_genes = as.vector(na.omit(sign_genes$gene_id[sign_genes$cor > 0]))
neg_genes = as.vector(na.omit(sign_genes$gene_id[sign_genes$cor < 0]))
print(Sys.time() - t0)
print(' - Analysis done!')
return(list(pi_corr_res = corr_df, pos_genes = pos_genes, neg_genes = neg_genes, coefs = coefs_df))}
mt_polycorr = PolyCorr(mt_poly, 9, samples_vec, 'holm')
View(mt_poly)
######################################################################################################
# POLYSUMMARY
# 1. data generation
mt_poly = PolySummary(data_mt, samples_vec[grepl('D',samples_vec)], 5)
######################################################################################################
# POLYSUMMARY
# 1. data generation
mt_poly = PolySummary(data_mt, samples_vec[grepl('D',samples_vec)], 0)
######################################################################################################
# POLYSUMMARY
# 1. data generation
mt_poly = PolySummary(data_mt, samples_vec[grepl('D',samples_vec)], 1)
######################################################################################################
# POLYSUMMARY
# 1. data generation
mt_poly = PolySummary(data_mt, samples_vec[grepl('D',samples_vec)], 6)
mt_polycorr = PolyCorr(mt_poly, 0, samples_vec, 'holm')
#' variable than can be either continuous, either discrete (handles two treatments). It creates
#' a zero-inflated poisson model of the SNP count, taking the sample, log(sequencing depth),
#' and the gene length as fixed effects. The idea is to identify genes showing signs of selective
#' sweeps associated with the target variable. There are three inputs:
#'   - data: the polymorphism data created by MetaPoly's "GetGenesData" function
#'   - min_samp: the minimal number of sample having the required depth to run the correlation test.
#'   - samp_vec: a vector that assigns each sample (vector values) to each population (vector
#'     names). The method handles two populations encoded as 0 and 1's.
#'
#' @export
PolyCorr <- function(data, min_samp, samp_vec, p_corr='holm'){
print('Launching - MetaPoly PolyCorr: a polymorphism-variable correlation tool for metagenomic data')
t0 = Sys.time()
print(' - Fitting a zero-inflated poisson model on the data...')
data = as.data.table(data[,colnames(data) %in% c('SNP_N', 'DEPTH', 'gene_length', 'sample', 'gene_id')])
print(data)
model_df = na.omit(data)
model = pscl::zeroinfl(SNP_N ~ log(DEPTH) + gene_length + as.factor(sample) | log(DEPTH), data = model_df)
print(summary(model))
model_df$res_m = model$residuals
model_df$variable = vapply(model_df$sample, function(x) as.numeric(names(samp_vec)[samp_vec == x]), numeric(1))
print(Sys.time() - t0)
print(' - Computing sample coefficients...')
coefs = coefficients(model)
coefs = coefs[startsWith(names(coefs),'count_as.factor(sample)')]
coefs_df = as.data.frame(coefs)
rownames(coefs_df) = vapply(rownames(coefs_df), function(x) strsplit(x, ')')[[1]][2], FUN.VALUE = character(1))
coefs_df$type = vapply(rownames(coefs_df), function(x) as.numeric(names(samp_vec)[samp_vec == x]), numeric(1))
print(Sys.time() - t0)
print(' - Computing correlations of polymorphism with the variable of interest per gene...')
corr_df = do.call(rbind, lapply(unique(model_df$gene_id), function(gene) fit_cor_gene(model_df[model_df$gene_id == gene,], gene, min_samp, samp_vec)))
corr_df$padj = p.adjust(corr_df$p, method = p_corr)
sign_genes = corr_df[corr_df$padj < 0.05,]
pos_genes = as.vector(na.omit(sign_genes$gene_id[sign_genes$cor > 0]))
neg_genes = as.vector(na.omit(sign_genes$gene_id[sign_genes$cor < 0]))
print(Sys.time() - t0)
print(' - Analysis done!')
return(list(pi_corr_res = corr_df, pos_genes = pos_genes, neg_genes = neg_genes, coefs = coefs_df))}
mt_polycorr = PolyCorr(mt_poly, 0, samples_vec, 'holm')
#' variable than can be either continuous, either discrete (handles two treatments). It creates
#' a zero-inflated poisson model of the SNP count, taking the sample, log(sequencing depth),
#' and the gene length as fixed effects. The idea is to identify genes showing signs of selective
#' sweeps associated with the target variable. There are three inputs:
#'   - data: the polymorphism data created by MetaPoly's "GetGenesData" function
#'   - min_samp: the minimal number of sample having the required depth to run the correlation test.
#'   - samp_vec: a vector that assigns each sample (vector values) to each population (vector
#'     names). The method handles two populations encoded as 0 and 1's.
#'
#' @export
PolyCorr <- function(data, min_samp, samp_vec, p_corr='holm'){
print('Launching - MetaPoly PolyCorr: a polymorphism-variable correlation tool for metagenomic data')
t0 = Sys.time()
print(' - Fitting a zero-inflated poisson model on the data...')
data = as.data.table(data[,colnames(data) %in% c('SNP_N', 'DEPTH', 'gene_length', 'sample', 'gene_id')])
print(data)
model_df = na.omit.data.table(data)
model = pscl::zeroinfl(SNP_N ~ log(DEPTH) + gene_length + as.factor(sample) | log(DEPTH), data = model_df)
print(summary(model))
model_df$res_m = model$residuals
model_df$variable = vapply(model_df$sample, function(x) as.numeric(names(samp_vec)[samp_vec == x]), numeric(1))
print(Sys.time() - t0)
print(' - Computing sample coefficients...')
coefs = coefficients(model)
coefs = coefs[startsWith(names(coefs),'count_as.factor(sample)')]
coefs_df = as.data.frame(coefs)
rownames(coefs_df) = vapply(rownames(coefs_df), function(x) strsplit(x, ')')[[1]][2], FUN.VALUE = character(1))
coefs_df$type = vapply(rownames(coefs_df), function(x) as.numeric(names(samp_vec)[samp_vec == x]), numeric(1))
print(Sys.time() - t0)
print(' - Computing correlations of polymorphism with the variable of interest per gene...')
corr_df = do.call(rbind, lapply(unique(model_df$gene_id), function(gene) fit_cor_gene(model_df[model_df$gene_id == gene,], gene, min_samp, samp_vec)))
corr_df$padj = p.adjust(corr_df$p, method = p_corr)
sign_genes = corr_df[corr_df$padj < 0.05,]
pos_genes = as.vector(na.omit(sign_genes$gene_id[sign_genes$cor > 0]))
neg_genes = as.vector(na.omit(sign_genes$gene_id[sign_genes$cor < 0]))
print(Sys.time() - t0)
print(' - Analysis done!')
return(list(pi_corr_res = corr_df, pos_genes = pos_genes, neg_genes = neg_genes, coefs = coefs_df))}
mt_polycorr = PolyCorr(mt_poly, 0, samples_vec, 'holm')
#' variable than can be either continuous, either discrete (handles two treatments). It creates
#' a zero-inflated poisson model of the SNP count, taking the sample, log(sequencing depth),
#' and the gene length as fixed effects. The idea is to identify genes showing signs of selective
#' sweeps associated with the target variable. There are three inputs:
#'   - data: the polymorphism data created by MetaPoly's "GetGenesData" function
#'   - min_samp: the minimal number of sample having the required depth to run the correlation test.
#'   - samp_vec: a vector that assigns each sample (vector values) to each population (vector
#'     names). The method handles two populations encoded as 0 and 1's.
#'
#' @export
PolyCorr <- function(data, min_samp, samp_vec, p_corr='holm'){
print('Launching - MetaPoly PolyCorr: a polymorphism-variable correlation tool for metagenomic data')
t0 = Sys.time()
print(' - Fitting a zero-inflated poisson model on the data...')
data = as.data.table(data[,colnames(data) %in% c('SNP_N', 'DEPTH', 'gene_length', 'sample', 'gene_id')])
print(data)
model_df = data.table::na.omit.data.table(data)
model = pscl::zeroinfl(SNP_N ~ log(DEPTH) + gene_length + as.factor(sample) | log(DEPTH), data = model_df)
print(summary(model))
model_df$res_m = model$residuals
model_df$variable = vapply(model_df$sample, function(x) as.numeric(names(samp_vec)[samp_vec == x]), numeric(1))
print(Sys.time() - t0)
print(' - Computing sample coefficients...')
coefs = coefficients(model)
coefs = coefs[startsWith(names(coefs),'count_as.factor(sample)')]
coefs_df = as.data.frame(coefs)
rownames(coefs_df) = vapply(rownames(coefs_df), function(x) strsplit(x, ')')[[1]][2], FUN.VALUE = character(1))
coefs_df$type = vapply(rownames(coefs_df), function(x) as.numeric(names(samp_vec)[samp_vec == x]), numeric(1))
print(Sys.time() - t0)
print(' - Computing correlations of polymorphism with the variable of interest per gene...')
corr_df = do.call(rbind, lapply(unique(model_df$gene_id), function(gene) fit_cor_gene(model_df[model_df$gene_id == gene,], gene, min_samp, samp_vec)))
corr_df$padj = p.adjust(corr_df$p, method = p_corr)
sign_genes = corr_df[corr_df$padj < 0.05,]
pos_genes = as.vector(na.omit(sign_genes$gene_id[sign_genes$cor > 0]))
neg_genes = as.vector(na.omit(sign_genes$gene_id[sign_genes$cor < 0]))
print(Sys.time() - t0)
print(' - Analysis done!')
return(list(pi_corr_res = corr_df, pos_genes = pos_genes, neg_genes = neg_genes, coefs = coefs_df))}
mt_polycorr = PolyCorr(mt_poly, 0, samples_vec, 'holm')
#' variable than can be either continuous, either discrete (handles two treatments). It creates
#' a zero-inflated poisson model of the SNP count, taking the sample, log(sequencing depth),
#' and the gene length as fixed effects. The idea is to identify genes showing signs of selective
#' sweeps associated with the target variable. There are three inputs:
#'   - data: the polymorphism data created by MetaPoly's "GetGenesData" function
#'   - min_samp: the minimal number of sample having the required depth to run the correlation test.
#'   - samp_vec: a vector that assigns each sample (vector values) to each population (vector
#'     names). The method handles two populations encoded as 0 and 1's.
#'
#' @export
PolyCorr <- function(data, min_samp, samp_vec, p_corr='holm'){
print('Launching - MetaPoly PolyCorr: a polymorphism-variable correlation tool for metagenomic data')
t0 = Sys.time()
print(' - Fitting a zero-inflated poisson model on the data...')
data = as.data.frame(data[,colnames(data) %in% c('SNP_N', 'DEPTH', 'gene_length', 'sample', 'gene_id')])
model_df = na.omit(data)
model = pscl::zeroinfl(SNP_N ~ log(DEPTH) + gene_length + as.factor(sample) | log(DEPTH), data = model_df)
print(summary(model))
model_df$res_m = model$residuals
model_df$variable = vapply(model_df$sample, function(x) as.numeric(names(samp_vec)[samp_vec == x]), numeric(1))
print(Sys.time() - t0)
print(' - Computing sample coefficients...')
coefs = coefficients(model)
coefs = coefs[startsWith(names(coefs),'count_as.factor(sample)')]
coefs_df = as.data.frame(coefs)
rownames(coefs_df) = vapply(rownames(coefs_df), function(x) strsplit(x, ')')[[1]][2], FUN.VALUE = character(1))
coefs_df$type = vapply(rownames(coefs_df), function(x) as.numeric(names(samp_vec)[samp_vec == x]), numeric(1))
print(Sys.time() - t0)
print(' - Computing correlations of polymorphism with the variable of interest per gene...')
corr_df = do.call(rbind, lapply(unique(model_df$gene_id), function(gene) fit_cor_gene(model_df[model_df$gene_id == gene,], gene, min_samp, samp_vec)))
corr_df$padj = p.adjust(corr_df$p, method = p_corr)
sign_genes = corr_df[corr_df$padj < 0.05,]
pos_genes = as.vector(na.omit(sign_genes$gene_id[sign_genes$cor > 0]))
neg_genes = as.vector(na.omit(sign_genes$gene_id[sign_genes$cor < 0]))
print(Sys.time() - t0)
print(' - Analysis done!')
return(list(pi_corr_res = corr_df, pos_genes = pos_genes, neg_genes = neg_genes, coefs = coefs_df))}
mt_polycorr = PolyCorr(mt_poly, 0, samples_vec, 'holm')
#' variable than can be either continuous, either discrete (handles two treatments). It creates
#' a zero-inflated poisson model of the SNP count, taking the sample, log(sequencing depth),
#' and the gene length as fixed effects. The idea is to identify genes showing signs of selective
#' sweeps associated with the target variable. There are three inputs:
#'   - data: the polymorphism data created by MetaPoly's "GetGenesData" function
#'   - min_samp: the minimal number of sample having the required depth to run the correlation test.
#'   - samp_vec: a vector that assigns each sample (vector values) to each population (vector
#'     names). The method handles two populations encoded as 0 and 1's.
#'
#' @export
PolyCorr <- function(data, min_samp, samp_vec, p_corr='holm'){
print('Launching - MetaPoly PolyCorr: a polymorphism-variable correlation tool for metagenomic data')
t0 = Sys.time()
print(' - Fitting a zero-inflated poisson model on the data...')
data = as.data.frame(data[,colnames(data) %in% c('SNP_N', 'DEPTH', 'gene_length', 'sample', 'gene_id')])
print(data)
model_df = na.omit(data)
print(model_df)
model = pscl::zeroinfl(SNP_N ~ log(DEPTH) + gene_length + as.factor(sample) | log(DEPTH), data = model_df)
print(summary(model))
model_df$res_m = model$residuals
model_df$variable = vapply(model_df$sample, function(x) as.numeric(names(samp_vec)[samp_vec == x]), numeric(1))
print(Sys.time() - t0)
print(' - Computing sample coefficients...')
coefs = coefficients(model)
coefs = coefs[startsWith(names(coefs),'count_as.factor(sample)')]
coefs_df = as.data.frame(coefs)
rownames(coefs_df) = vapply(rownames(coefs_df), function(x) strsplit(x, ')')[[1]][2], FUN.VALUE = character(1))
coefs_df$type = vapply(rownames(coefs_df), function(x) as.numeric(names(samp_vec)[samp_vec == x]), numeric(1))
print(Sys.time() - t0)
print(' - Computing correlations of polymorphism with the variable of interest per gene...')
corr_df = do.call(rbind, lapply(unique(model_df$gene_id), function(gene) fit_cor_gene(model_df[model_df$gene_id == gene,], gene, min_samp, samp_vec)))
corr_df$padj = p.adjust(corr_df$p, method = p_corr)
sign_genes = corr_df[corr_df$padj < 0.05,]
pos_genes = as.vector(na.omit(sign_genes$gene_id[sign_genes$cor > 0]))
neg_genes = as.vector(na.omit(sign_genes$gene_id[sign_genes$cor < 0]))
print(Sys.time() - t0)
print(' - Analysis done!')
return(list(pi_corr_res = corr_df, pos_genes = pos_genes, neg_genes = neg_genes, coefs = coefs_df))}
mt_polycorr = PolyCorr(mt_poly, 0, samples_vec, 'holm')
#' variable than can be either continuous, either discrete (handles two treatments). It creates
#' a zero-inflated poisson model of the SNP count, taking the sample, log(sequencing depth),
#' and the gene length as fixed effects. The idea is to identify genes showing signs of selective
#' sweeps associated with the target variable. There are three inputs:
#'   - data: the polymorphism data created by MetaPoly's "GetGenesData" function
#'   - min_samp: the minimal number of sample having the required depth to run the correlation test.
#'   - samp_vec: a vector that assigns each sample (vector values) to each population (vector
#'     names). The method handles two populations encoded as 0 and 1's.
#'
#' @export
PolyCorr <- function(data, min_samp, samp_vec, p_corr='holm'){
print('Launching - MetaPoly PolyCorr: a polymorphism-variable correlation tool for metagenomic data')
t0 = Sys.time()
print(' - Fitting a zero-inflated poisson model on the data...')
data = as.data.frame(data[,colnames(data) %in% c('SNP_N', 'DEPTH', 'gene_length', 'sample', 'gene_id')])
print(data)
model_df = na.omit(data)
print(nrow(is.na(model_df)))
model = pscl::zeroinfl(SNP_N ~ log(DEPTH) + gene_length + as.factor(sample) | log(DEPTH), data = model_df)
print(summary(model))
model_df$res_m = model$residuals
model_df$variable = vapply(model_df$sample, function(x) as.numeric(names(samp_vec)[samp_vec == x]), numeric(1))
print(Sys.time() - t0)
print(' - Computing sample coefficients...')
coefs = coefficients(model)
coefs = coefs[startsWith(names(coefs),'count_as.factor(sample)')]
coefs_df = as.data.frame(coefs)
rownames(coefs_df) = vapply(rownames(coefs_df), function(x) strsplit(x, ')')[[1]][2], FUN.VALUE = character(1))
coefs_df$type = vapply(rownames(coefs_df), function(x) as.numeric(names(samp_vec)[samp_vec == x]), numeric(1))
print(Sys.time() - t0)
print(' - Computing correlations of polymorphism with the variable of interest per gene...')
corr_df = do.call(rbind, lapply(unique(model_df$gene_id), function(gene) fit_cor_gene(model_df[model_df$gene_id == gene,], gene, min_samp, samp_vec)))
corr_df$padj = p.adjust(corr_df$p, method = p_corr)
sign_genes = corr_df[corr_df$padj < 0.05,]
pos_genes = as.vector(na.omit(sign_genes$gene_id[sign_genes$cor > 0]))
neg_genes = as.vector(na.omit(sign_genes$gene_id[sign_genes$cor < 0]))
print(Sys.time() - t0)
print(' - Analysis done!')
return(list(pi_corr_res = corr_df, pos_genes = pos_genes, neg_genes = neg_genes, coefs = coefs_df))}
mt_polycorr = PolyCorr(mt_poly, 0, samples_vec, 'holm')
View(mt_poly)
#' variable than can be either continuous, either discrete (handles two treatments). It creates
#' a zero-inflated poisson model of the SNP count, taking the sample, log(sequencing depth),
#' and the gene length as fixed effects. The idea is to identify genes showing signs of selective
#' sweeps associated with the target variable. There are three inputs:
#'   - data: the polymorphism data created by MetaPoly's "GetGenesData" function
#'   - min_samp: the minimal number of sample having the required depth to run the correlation test.
#'   - samp_vec: a vector that assigns each sample (vector values) to each population (vector
#'     names). The method handles two populations encoded as 0 and 1's.
#'
#' @export
PolyCorr <- function(data, min_samp, samp_vec, p_corr='holm'){
print('Launching - MetaPoly PolyCorr: a polymorphism-variable correlation tool for metagenomic data')
t0 = Sys.time()
print(' - Fitting a zero-inflated poisson model on the data...')
data = as.data.frame(data)
print(data)
model_df = na.omit(data[,colnames(data) %in% c('SNP_N', 'DEPTH', 'gene_length', 'sample', 'gene_id')])
print(nrow(is.na(model_df)))
model = pscl::zeroinfl(SNP_N ~ log(DEPTH) + gene_length + as.factor(sample) | log(DEPTH), data = model_df)
print(summary(model))
model_df$res_m = model$residuals
model_df$variable = vapply(model_df$sample, function(x) as.numeric(names(samp_vec)[samp_vec == x]), numeric(1))
print(Sys.time() - t0)
print(' - Computing sample coefficients...')
coefs = coefficients(model)
coefs = coefs[startsWith(names(coefs),'count_as.factor(sample)')]
coefs_df = as.data.frame(coefs)
rownames(coefs_df) = vapply(rownames(coefs_df), function(x) strsplit(x, ')')[[1]][2], FUN.VALUE = character(1))
coefs_df$type = vapply(rownames(coefs_df), function(x) as.numeric(names(samp_vec)[samp_vec == x]), numeric(1))
print(Sys.time() - t0)
print(' - Computing correlations of polymorphism with the variable of interest per gene...')
corr_df = do.call(rbind, lapply(unique(model_df$gene_id), function(gene) fit_cor_gene(model_df[model_df$gene_id == gene,], gene, min_samp, samp_vec)))
corr_df$padj = p.adjust(corr_df$p, method = p_corr)
sign_genes = corr_df[corr_df$padj < 0.05,]
pos_genes = as.vector(na.omit(sign_genes$gene_id[sign_genes$cor > 0]))
neg_genes = as.vector(na.omit(sign_genes$gene_id[sign_genes$cor < 0]))
print(Sys.time() - t0)
print(' - Analysis done!')
return(list(pi_corr_res = corr_df, pos_genes = pos_genes, neg_genes = neg_genes, coefs = coefs_df))}
mt_polycorr = PolyCorr(mt_poly, 0, samples_vec, 'holm')
